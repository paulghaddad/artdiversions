---
layout: post
title:  "37signals does it again"
date:   2014-02-25 20:53:24
author: "Amy"
excerpt: "Hello"
---
    <h2><em><a href="author-link">David</a> wrote this on <time datetime="2014-01-21">Jan 21, 2014</time> / <a href="">13 Comments</a></em></h2> 

    <p>The majority of Ajax operations in Basecamp are handled with Server-generated JavaScript Responses (SJR). It works like this:</p>

    <ol>
        <li>Form is submitted via a XMLHttpRequest-powered form.</li>
        <li>Server creates or updates a model object.</li>
        <li>Server generates a JavaScript response that includes the updated HTML template for the model.</li>
        <li>Client evaluates the JavaScript returned by the server, which then updates the DOM.</li>
    </ol>

    <p>This simple pattern has a number of key benefits.</p>

    <h3>Benefit #1: Reuse templates without sacrificing performance</h3>

    <p>You get to reuse the template that represents the model for both first-render and subsequent updates. In Rails, you’d have a partial like messages/message that’s used for both cases.</p>

    <p>If you only returned JSON, you’d have to implement your templates for showing that message twice (once for first-response on the server, once for subsequent-updates on the client) — unless you’re doing a single-page JavaScript app where even the first response is done with JSON/client-side generation.</p>

    <p>That latter model can be quite slow, since you won’t be able to display anything until your entire JavaScript library has been loaded and then the templates generated client-side. (This was the model that Twitter originally tried and then backed out of). But at least it’s a reasonable choice for certain situations and doesn’t require template duplication.</p>

    <h3>Benefit #2: Less computational power needed on the client</h3>

    <p>While the JavaScript with the embedded HTML template might result in a response that’s marginally larger than the same response in JSON (although that’s usually negligible when you compress with gzip), it doesn’t require much client-side computation to update.</p>

    <p>This means it might well be faster from an end-to-end perspective to send JavaScript+HTML than JSON with client-side templates, depending on the complexity of those templates and the computational power of the client. This is double so because the server-generated templates can often be cached and shared amongst many users (see Russian Doll caching).</p>

    <h3>Benefit #3: Easy-to-follow execution flow</h3>

    <p>It’s very easy to follow the execution flow with SJR. The request mechanism is standardized with helper logic like form_for @post, remote: true. There’s no need for per-action request logic. The controller then renders the response partial view in exactly the same way it would render a full view, the template is just JavaScript instead of straight HTML.</p>

    <h3>Complete example</h3>

    <p>0) First-use of the message template.</p>

    <p>1) Form submitting via Ajax.</p>

    <p>2) Server creates the model object.</p>

    <p>3) Server generates a JavaScript response with the HTML embedded.</p>

    <p>The final step of evaluating the response is automatically handled by the XMLHttpRequest-powered form generated by form_for, and the view is thus updated with the new message and that new message is then highlighted via a JS/CSS animation.</p>

    <h3>Beyond RJS</h3>

    <p>When we first started using SJR, we used it together with a transpiler called RJS, which had you write Ruby templates that were then turned into JavaScript. It was a poor man’s version of CoffeeScript (or Opalrb, if you will), and it erroneously turned many people off the SJR pattern.</p>

    <p>These days we don’t use RJS any more (the generated responses are usually so simple that the win just wasn’t big enough for the rare cases where you actually do need something more complicated), but we’re as committed as ever to SJR.</p>

    <p>This doesn’t mean that there’s no place for generating JSON on the server and views on the client. We do that for the minority case where UI fidelity is very high and lots of view state is maintained, like our calendar. When that route is called for, we use Sam’s excellent Eco template system (think ERB for CoffeeScript).</p>

    <p>If your web application is all high-fidelity UI, it’s completely legit to go this route all the way. You’re paying a high price to buy yourself something fancy. No sweat. But if your application is more like Basecamp or Github or the majority of applications on the web that are proud of their document-based roots, then you really should embrace SJR with open arms.</p>

    <p>The combination of Russian Doll-caching, Turbolinks, and SJR is an incredibly powerful cocktail for making fast, modern, and beautifully coded web applications. Enjoy!</p>

    

